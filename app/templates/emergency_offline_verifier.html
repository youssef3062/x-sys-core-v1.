{% extends "base.html" %}
{% block content %}
<div class="container py-5" style="max-width: 760px;">
  <h3 class="mb-3"><i class="fas fa-heartbeat text-danger"></i> Offline Emergency Verification</h3>
  <p class="text-muted">This page verifies emergency QR tokens locally in your browser. No server call is required for signature checks.</p>

  <div class="mb-3">
    <label class="form-label">Signed Token</label>
    <textarea id="tokenInput" class="form-control" rows="5" placeholder="Paste token or open this page with #token=... in URL"></textarea>
  </div>

  <button id="verifyBtn" class="btn btn-primary">Verify Offline</button>
  <div id="status" class="mt-3"></div>
  <pre id="payload" class="mt-3 p-3 bg-light border rounded" style="white-space: pre-wrap;"></pre>
</div>

<script>
const PUBLIC_KEY_PEM = {{ public_key_pem|tojson }};

function b64urlToBytes(s) {
  const pad = '='.repeat((4 - (s.length % 4)) % 4);
  const b64 = (s + pad).replace(/-/g, '+').replace(/_/g, '/');
  const raw = atob(b64);
  return Uint8Array.from(raw, c => c.charCodeAt(0));
}

function parsePemToArrayBuffer(pem) {
  const base64 = pem.replace(/-----BEGIN PUBLIC KEY-----/g, '')
                    .replace(/-----END PUBLIC KEY-----/g, '')
                    .replace(/\s+/g, '');
  return b64urlToBytes(base64.replace(/\+/g, '-').replace(/\//g, '_')).buffer;
}

function decodePart(part) {
  return JSON.parse(new TextDecoder().decode(b64urlToBytes(part)));
}

async function verifyTokenOffline(token) {
  const [h, p, s] = token.split('.');
  if (!h || !p || !s) return {status: 'Invalid', reason: 'Malformed token'};

  const header = decodePart(h);
  const payload = decodePart(p);
  if (header.alg !== 'EdDSA') return {status: 'Invalid', reason: 'Unsupported algorithm'};

  const keyData = parsePemToArrayBuffer(PUBLIC_KEY_PEM);
  let publicKey;
  try {
    publicKey = await crypto.subtle.importKey('spki', keyData, {name: 'Ed25519'}, false, ['verify']);
  } catch {
    return {status: 'Invalid', reason: 'Browser does not support Ed25519 WebCrypto'};
  }

  const ok = await crypto.subtle.verify(
    {name: 'Ed25519'},
    publicKey,
    b64urlToBytes(s),
    new TextEncoder().encode(`${h}.${p}`)
  );

  if (!ok) return {status: 'Invalid', reason: 'Signature mismatch'};
  if (!payload.exp || payload.exp <= Math.floor(Date.now() / 1000)) {
    return {status: 'Expired', payload};
  }
  return {status: 'Verified', payload};
}

async function runVerify() {
  const token = document.getElementById('tokenInput').value.trim();
  const statusEl = document.getElementById('status');
  const payloadEl = document.getElementById('payload');
  if (!token) {
    statusEl.innerHTML = '<div class="alert alert-warning">Token is required.</div>';
    return;
  }

  const result = await verifyTokenOffline(token);
  const klass = result.status === 'Verified' ? 'success' : (result.status === 'Expired' ? 'warning' : 'danger');
  statusEl.innerHTML = `<div class="alert alert-${klass}"><strong>${result.status}</strong>${result.reason ? ': ' + result.reason : ''}</div>`;
  payloadEl.textContent = result.payload ? JSON.stringify(result.payload, null, 2) : '';
}

document.getElementById('verifyBtn').addEventListener('click', runVerify);

if (location.hash.startsWith('#token=')) {
  const token = decodeURIComponent(location.hash.slice(7));
  document.getElementById('tokenInput').value = token;
}
</script>
{% endblock %}
